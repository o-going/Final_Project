<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
   <!--Bootstrap-->
   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
   <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
   <script src="https://code.jquery.com/jquery-3.5.1.min.js" crossorigin="anonymous"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
   <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
   
   <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/select2/3.5.0/select2.min.css"></link>

   <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
   <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/select2/3.5.0/select2.min.js"></script>
   <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.11/d3.min.js"></script>

   <link rel="stylesheet" href="css/style.css">
   <link rel="stylesheet" href="css/techtree.css">
   <link rel="preconnect" href="https://fonts.gstatic.com">
   <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700;900&display=swap" rel="stylesheet">   
  
   <style>
     body {
       text-align: center;
     }

     svg {
       margin-top: 55px;
       border: 1px solid #aaa;
     }

     .node rect {
       fill: #fff;
       stroke: steelblue;
       stroke-width: 1px;
     }

     .node text{
       font: 13px sans-serif;
     }

     .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 1.5px;
    }
   </style>

   <title>Document</title>
</head>
<body>
  <!-- Navigation-->
  <nav id="menu" class="navbar navbar-default navbar-fixed-top">
    <div class="container"> 
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <a class="navbar-brand page-scroll" href="/">Logo</a> 
      </div>
      <div class="navbar-brand" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav navbar-right">
          <li><a href="techtree" class="page-scroll">TechTree</a></li>
          <li><a href="Login" class="page-scroll">Login</a></li>
        </ul>
      </div>
    </div>
  </nav>
  <!-- <p>
    Scale nodes and edges depending on their value. Hover over nodes and edges to
    get more information.
  </p> -->

  <!-- <div id="search">
  </div> -->
  <button class="btn btn-primary ml-5" data-toggle="portfilter" data-target="all" onclick="recommend()">  <!--click 했을 때 event-->
    다음
  </button>
  <button class="btn btn-secondary ml-5" data-toggle="portfilter" data-target="all" onclick="saveData()">  <!--click 했을 때 event-->
    저장
  </button>
  <button class="btn btn-light ml-5" data-toggle="portfilter" data-target="all" onclick="refresh()">
    초기화
  </button>

  <script type="text/javascript">
  window.addEventListener("load", function() {
    if(window.sessionStorage.getItem('data') != null) {
      console.log('aa');
      techs = JSON.parse(window.sessionStorage.getItem('data'))
      for (t of techs) {
        var paths = searchTree(root, t, []);
        if(typeof(paths) !== "undefined") {
          openPaths(paths);
          console.log(paths);
        }
        else{
          alert(t +" not found!");
        }
      }
    }
  })

    function recommend() {  // click 했을 떄 event 함수
      let save = [];
      let save2 = [];
      search_select_node(root, save)
      for(i of save) {
        save2.push(i.name); //save 객체의 name만 뽑아서 push
        
      }
      console.log(save2);
      console.log(save);
      //fetch("/recommend2?data="+JSON.stringify(save2))
      sessionStorage.setItem('data', JSON.stringify(save2));
      // let data = JSON.parse(sessionStorage.getItem('item'));

      window.location = "/recommend?data="+encodeURIComponent(JSON.stringify(save2)) // window.location으로 주소로 data를 문자열로 보내줌
    }

    function refresh() {
      sessionStorage.removeItem('data');
      window.location.reload();
    }

    function saveData() {
      let save = [];
      let save2 = [];
      search_select_node(root, save)
      for(i of save) {
        save2.push(i.name); //save 객체의 name만 뽑아서 push
        
      }
      console.log(save2);

      $.ajax({
        url: '/techtree',
        method: 'GET',
        headers: {
          "Content-type": "application/json; charset=UTF-8"
        },
        data: JSON.stringify({
          data: save2
        }),
        success: function(response) {
          alert('OK!')
        },
        error: function(err) {
          alert('fail!')
        }
      });
    }

    //basically a way to get the path to an object
    function searchTree(obj,search,path) {
      if(obj.name === search){ //if search is found return, add the object to the path and return it
        path.push(obj);
        return path;
      }
      else if(obj.children || obj._children){ //if children are collapsed d3 object will have them instantiated as _children
        var children = (obj.children) ? obj.children : obj._children;
        for(var i=0; i<children.length; i++){
          path.push(obj);// we assume this path is the right one
          var found = searchTree(children[i],search,path);
          if(found){// we were right, this should return the bubbled-up path from the first if statement
            return found;
          }
          else{//we were wrong, remove this parent from the path and continue iterating
            path.pop();
          }
        }
      }
      else{//not the right object, return false so it will continue to iterate in the loop
        return false;
      }
      
    }

    function search_select_node(obj, path) { 
      let root = "Programming Language";
      if(obj.children || obj._children){ //if children are collapsed d3 object will have them instantiated as _children
        var children = (obj.children) ? obj.children : obj._children; // children이 펴져있는 애들이면 children, 접혀있는 애들이면 _children
        let flag = true;
        for(var i=0; i<children.length; i++){ 
          if (children[i].class == 'found') { // children의 class가(선택되어) found면
            search_select_node(children[i],path); // 재귀로 children을 계속 돔
            // flag = false; // flag를 false로 변환(없으면) => 걸림
          }
        }
        if (flag) { 
          if(obj.name != root) {
            path.push(obj); // 만약 class가 found면 path에 해당 children을 넣어줌
          }
          // path.push(obj); // path에 해당 children을 넣어줌
        }
      }else {
        if(obj.class == 'found') {
          if(obj.name != root) {
            path.push(obj); // 만약 class가 found면 path에 해당 children을 넣어줌
          }
        }
      }
    }
  
    function extract_select2_data(node,leaves,index) {
            if (node.children){
                for(var i = 0; i<node.children.length; i++){
                    index = extract_select2_data(node.children[i],leaves,index)[0];
                }
            }
            else {
                leaves.push({id:++index,text:node.name});
            }
            return [index,leaves];
    }
    
    let zoom = d3.behavior.zoom()
      .scaleExtent([.1,1])
      .on('zoom', function() {
        svg.attr('transform', 'translate(' + d3.event.translate + ') scale(' + d3.event.scale + ')');
      })
      .translate([150,200]);


    var div = d3.select("body")
      .append("div") // declare the tooltip div
      .attr("class", "tooltip")
      .style("opacity", 0);
  
    var margin = {top: 700, right: 200, bottom: 0, left: 250},
      width = 1500 - margin.right - margin.left,
      height = 1400 - margin.top - margin.bottom;
  
    var i = 0,
      duration = 750,
      root,
      select2_data;
  
    var diameter = 960;
  
    var tree = d3.layout.tree()
      // .size([height, width])
      .nodeSize([60, 100])
      .separation(function() {
        return .6;
      })
  
    var diagonal = d3.svg.diagonal()
      .projection(function(d) { return [d.y, d.x]; });
    
    let boxWidth = 150,
        boxHeight = 40;

    var svg = d3.select("body").append("svg")
      .attr("width", width + margin.right + margin.left)
      .attr("height", height + margin.top + margin.bottom)
      // .attr('width', 1500)
      // .attr('height', 800)
      .append("g")
      // .call(zoom)
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      // .attr('transform', 'translate(150,200)');
  
    //recursively collapse children
    function collapse(d) {
      if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
      }
    }
  
    // Toggle children on click
    function click(d) {
      if(d.class == 'found') {
        d.class = '';
      }else {
        d.class = 'found';
      }

      if (d.children) {
        d._children = d.children;
        d.children = null;
        }
        else{
        d.children = d._children;
        d._children = null;
        }
      update(d);
    }
  
    function openPaths(paths) {
      for(var i =0; i<paths.length; i++){
        if(paths[i].id !== "1"){
          paths[i].class = 'found';
          if(paths[i]._children){
            paths[i].children = paths[i]._children;
              paths[i]._children = null;
          }
          update(paths[i]);
        }
      }
    }
  
    d3.json("js/data.json", function(error,values){
      if(error) {
        return console.error(error);
      }

      root = values;
      select2_data = extract_select2_data(values,[],0)[1];

      root.x0 = height / 2;
      // root.x0 = 0;
      root.y0 = 0;
      root.children.forEach(collapse);
      update(root);
      //init search box
      // $("#search").select2({
      //   data: select2_data,
      //   containerCssClass: "search"
      // });
    });

    // attach search box listener
    $("#search").on("select2-selecting", function(e) {
      var paths = searchTree(root,e.object.text,[]);
      if(typeof(paths) !== "undefined"){
        openPaths(paths);
        console.log('path')
        console.log(paths);
      }
      else{
        alert(e.object.text+" not found!");
      }
    })
  
    d3.select(self.frameElement).style("height", "1000px");
  
    function update(source) {
      // Compute the new tree layout.
      var nodes = tree.nodes(root).reverse(),
      links = tree.links(nodes);
  
      // Normalize for fixed-depth.
      nodes.forEach(function(d) { d.y = d.depth * 150; });
  
      // Update the nodesâ€¦
      var node = svg.selectAll("g.node")
        .data(nodes, function(d) { return d.id || (d.id = ++i); });
  
      // Enter any new nodes at the parent's previous position.
      var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      // .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .attr('transform', function(d) {
        return 'translate(' + (source.x0 + boxWidth/2) + ',' + source.y0 + ')';
      })
      .on("click", click);
      // .on('click', togglePerson);
  
      nodeEnter.append("circle")
      .attr("r", 1e-6)
      .attr('class', 'circle')
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

      // nodeEnter.append('rect')
      //   .attr({
      //     x: 0,
      //     y: 0,
      //     width: 0,
      //     height: 0
      //   });

      nodeEnter.append("text")
        .attr("dx", function(d) { return d.children || d._children ? -10 : 10; })
        .attr("dy", ".35em")
        .attr('class', 'name')
        .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
        .text(function(d) { return d.name; })
        .style("fill-opacity", 1e-6);
        // .attr('dx', 5)
        // .attr('dy', -50)
        // .attr('text-anchor', 'start')
        // .attr('class', 'name')
        // .text(function(d) {
        //   return d.name;
        // })
        // .style('fill-opacity', 0);
  
      // Transition nodes to their new position.
      var nodeUpdate = node.transition()
        .duration(duration)
        .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
  
      nodeUpdate.select("circle")
        .attr("r", 4.5)
        .style("fill", function(d) {
          if(d.class === "found"){
            return "#ff4136"; //red
          }
          else if(d._children){
            return "lightsteelblue";
          }
          else{
            return "#fff";
          }
        })
        .style("stroke", function(d) {
          if(d.class === "found"){
            return "#ff4136"; //red
          }
      });

      // nodeUpdate.select('rect')
      //   .attr({
      //     x: -(boxWidth/2),
      //     y: -(boxWidth/2),
      //     width: boxWidth,
      //     height: boxHeight
      //   })
      //   .style('fill', function(d) {
      //     if(d.class === 'found') {
      //       return '#549BD6';
      //     }else if(d._children) {
      //       return 'lightsteelblud';
      //     }else {
      //       return '#fff';
      //     }
      //   })
      //   .style('stroke', function(d) {
      //     if(d.class === 'found') {
      //       return '#549BD6';
      //     }
      //   });
        
      nodeUpdate.select("text")
        .style("fill-opacity", 1);
      // nodeUpdate.select('text')
      //   .attr('dx', -(boxWidth/2) + 5)
      //   .style('fill-opacity', 1);
  
      // Transition exiting nodes to the parent's new position.
      var nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
        .remove();
  
      nodeExit.select("circle")
        .attr("r", 1e-2);
      // nodeExit.select('rect')
      //   .attr({
      //     x: 0,
      //     y: 0,
      //     width: 0,
      //     height: 0
      //   });
  
      nodeExit.select("text")
        .style("fill-opacity", 1e-6);
      // nodeExit.select('text')
      //   .style('fill-opacity', 0)
      //   .attr('dy', 0);
        
      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      })
  
      // Update the linksâ€¦
      var link = svg.selectAll("path.link")
        .data(links, function(d) { return d.target.id; });
  
      // Enter any new links at the parent's previous position.
      link.enter().insert("path", "g")
        .attr("class", "link")
        .attr("d", function(d) {
          var o = {x: source.x0, y: source.y0};
          return diagonal({source: o, target: o});
        });
      // link.enter().append('path')
      //   .attr('class', 'link')
      //   .attr('d', function(d) {
      //     let o = {x: source.x0, y: (source.y0 + boxWidth/2)};
      //     return transitionElbow({source: o, target: o});
      //   });
  
      // Transition links to their new position.
      link.transition()
        .duration(duration)
        .attr("d", diagonal)
        .style("stroke",function(d){
          if(d.target.class==="found"){
            return "#ff4136";
          }
        });
      // link.transition()
      //   .duration(duration)
      //   .attr('d', diagonal)
      //   .style('stroke', function(d) {
      //     if(d.target.class === 'found') {
      //       return '#ff4136';
      //     }
      //   })
      //   .attr('d', elbow);
  
      // Transition exiting nodes to the parent's new position.
      link.exit().transition()
        .duration(duration)
        .attr("d", function(d) {
          var o = {x: source.x, y: source.y};
          // let o = {x: source.x, y: (source.y + boxWidth/2)};
          return diagonal({source: o, target: o});
          // return transitionElbow({source: o, target: o});
        })
        .remove();
  
      // Stash the old positions for transition.
      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
        });
    }

    function elbow(d) {
        var sourceX = d.source.x,
            sourceY = d.source.y + (boxWidth / 2),
            targetX = d.target.x,
            targetY = d.target.y - (boxWidth / 2);

        return "M" + sourceY + "," + sourceX
          + "H" + (sourceY + (targetY-sourceY)/2)
          + "V" + targetX 
          + "H" + targetY;
      }

    function transitionElbow(d){
        return "M" + d.source.x + "," + d.source.x
          + "H" + d.source.y
          + "V" + d.source.x 
          + "H" + d.source.y;
    }

  </script>










  <!-- <script>
    var nodes = null;
    var edges = null;
    var network = null;

  function draw(nodes, edges) {
  // create people.
  // value corresponds with the age of the person

  // Instantiate our network object.
/*
  var container = document.getElementById("mynetwork");
  var data = {
    nodes: nodes,
    edges: edges,
  };
  var options = {
    nodes: {
      shape: "dot",
      scaling: {
        customScalingFunction: function (min, max, total, value) {
          return value / total;
        },
        min: 1,
        max: 1,
      },
    },
    layout: {
      improvedLayout: false
    },
    physics: false,
  };
  network = new vis.Network(container, data, options);
*/
 
  var container = document.getElementById("mynetwork");
  var options = {
    nodes: {
      // color: '#000000',
      shape: "dot",
      scaling: {
        min: 10,
        max: 100,
        // label: {
        //   min: 12,
        //   max: 30,
        //   drawThreshold: 12,
        //   maxVisible: 50,
        // },
      },
      font: {
        size: 24,
        face: "Tahoma",
        bold: {
          size: 30,
          vadjust: 0,
          mod: 'bold'
        }
      },
    },
    edges: {
      width: 0.10,
      color: { inherit: true },
      smooth: {
        type: "continuous",
      },
    },
    physics: false,
    interaction: {
      tooltipDelay: 200,
      hideEdgesOnDrag: true,
      //hideEdgesOnZoom: true,
    },
    layout: {
      improvedLayout: false
    },
  };

  var data = { nodes: nodes, edges: edges };
  // Note: data is coming from ./data/WorldCup2014.js
  network = new vis.Network(container, data, options);
  
}

window.addEventListener("load", () => {
  fetch("/dataset")
    .then(response => response.json())
    .then(json => {
      console.log(json.nodes, json.edges);
      draw(json.nodes, json.edges);
    });
});

  </script> -->
</body>
</html>